이 글은, [전문가를 위한 파이썬] 14챕터를 한번 읽었다고 가정하고 작성한, 
해당 챕터 요약 글입니다.

데이터 처리에 반복은 기본이다. 그런데, 반복을 할 대상 데이터가 너무 크면, 당장 처리해야하는 양 만큼의 최소 데이터만을 메모리에 올려 느긋(lazy) 하게 반복할 수 있어야 한다. 이것을 파이썬에서는 어떻게 할 수 있나?

<개념정리>

yield 키워드: 2001년 파이썬 2.2에 추가됨, 반복자로 작동하는 Generator 를 생성할 수 있게 해준다.

1. 반복형 (Iterable)

우리가 아는 일반적인 반복형

- For loop
- 컬렉션형 생성 및 확장
- 텍스트 파일 한줄씩 읽어들이기
- 지능형 list / dict / set 등
- 언패킹 (*args, **kwargs)


어떤게 반복형인가.

- 파이썬의 컬렉션
- __iter__() 함수가 반복자를 가져올 수 있는 모든 객체
- 반복자를 반환하는 __iter__() 를 구현하는 객체
- 0 부터 시작하는 index 를 받는 __getitem__() 메서드를 구현하는 객체

그냥 심플하게… __iter__() 메서드를 구현한 클래스


분명하게 기억해야할것 !!!

: 반복형이 반복자를 가져온다

헤깔리니까 반복합시다.

반복형이 반복자를 가져온다
반복형이 반복자를 가져온다
반복형이 반복자를 가져온다



2. 반복자 (Iterator)

간단 정의
: 다음 항목을 반환하거나, 그게 없으면 StopIteration 예외를 발생시키는 인수 없는 __next__() 를 구현하는 객체, __iter__() 을 구현하므로 반복형이기도 함.

조금 더 자세한 정의
: 아래의 표준 프로토콜(인터페이스)을 구현한 모든 객체

__next__() : 다음 항목을 불러옴, 없으면 StopIteration 예외 발생
__iter__() : self 를 반환

위 성질 때문에, 파이썬에서 반복자는 자료형이 아닌 그냥 프로토콜이라고 한다.




변수 x 가 반복자인지 확인하는법
isinstance(x, abc.Iterator) == True

반복자의 중요한 성질

반복자는 항목을 소진 하던 중간에 처음 항목을 다시 가져오기 위한 "재설정" 이 불가능하다.
그냥 반복형의 __iter__() 를 호출하여 반복자를 새로생성 해야함.

생성된 반복자는 각각의 고유한 내부 상태를 유지해야 한다.
즉, 독립성을 가져야 함



3. 제너레이터 (Generator)

모든 제너레이터는 반복자다. 
왜냐하면 반복자 프로토콜(인터페이스)를 완전히 구현하고 있기 때문.

그런데 한가지 큰 차이점이 있다면, 
반복자는 [디자인 패턴]에서 정의한대로 이미 정의된 컬렉션 데이터로부터 항목을 하나씩 가져오지만, Generator 는 [마술처럼] 항목을 생성(yield) 해낸다.

제너레이터는 값을 반환하는것이 아닌 "생성" 한다.
generator 함수 안에있는 return 문은 StopIteration 예외를 자동으로 발생시킨다.

제너레이터 함수 : 함수 본체에 yield 키워드를 포함하고 있는 것.

제너레이터 함수  → call → 제너레이터 객체
위 성질때문에 제너레이터 함수 = 제너레이터 팩토리

제너레이터를 혹시라도 직접 만들일이 있으면 그 전에,
표준 라이브러리 itertools 나 functools 에서 제공하는 generator 들을 먼저 살피자.


4. 제너레이터 표현식 (Generator Expression)

제너레이터 표현식은 generator 로 iteration 을 돌리는 list comprehension 에서 대괄호 대신 괄호를 사용하면 된다.

제너레이터 표현식을 사용하면 실제 iteration 을 전부 돌지 않으므로 메모리가 절약된다.

제너레이터 표현식 보다 제너레이터 함수 를 선호하는 경우
- 표현식으로 구현했을때, 코드가 2줄 이상인 경우
- 로직의 재사용이 필요한 경우.

